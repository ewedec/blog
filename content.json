{"meta":{"title":"超哥博客","subtitle":"打造码农的世界","description":null,"author":"Dingchao.Wu","url":"https://ewedwc.github.io"},"pages":[],"posts":[{"title":"Docker基础","slug":"Docker基础","date":"2018-11-14T02:52:58.000Z","updated":"2018-11-15T07:34:55.163Z","comments":true,"path":"categories/1d9fbb6a.html","link":"","permalink":"https://ewedwc.github.io/categories/1d9fbb6a.html","excerpt":"","text":"1.安装Docker linux安装Docker12345678#安装curl命令sudo apt-get install curl#安装Dockercurl -fsSl https://get.Docker.com |sh#检查Dockersudo docker version#将当前用户添加到docker组中免敲sudo命令sudo useradd -aG docker 当前用户名 1234567#使用不同的的源 官方源: curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) st able&quot;阿里云的源&#123;推荐&#125; curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add - add-apt-repository &quot;deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_relea se -cs) stable&quot; Mac安装Docker 1官网下载Docker for Mac 进行安装 Docker 删除 123apt-get purge docke-ce -yrm -rf /var/lib/docer/rm - rf /etc/docker Docker加速器&emsp;&emsp;在国内使用docker的官方镜像源，会因为网络的原因，造成无法下载，或者一直处于超时。所以我们使用 daocloud 的方法进行加速配置。 2.Docker介绍 Docker是什么Docker是一个开源的容器引擎，它基于LXC（LXC又名Linux container，是一种虚拟化的解决方案，这种是内核级的虚拟化。(主流的解决方案Xen ,KVM, LXC)）容器技术，使用GO语言开发。遵循Apache2.0协议。Docker采用C/S架构，其可以为任何应用创建一个轻量级、可移植的、自给自足的容器。Docker就是一种快速解决生产问题的一种技术手段。 Docker的特点 三大理念：构建:&emsp;&emsp;将你需要的场景构建好，装在一个镜像中，就好比龙珠中的胶囊一样。运输:&emsp;&emsp;随身携带非常方便运行:&emsp;&emsp;只要在需要的地方一放，打开使用就OK了 优点:&emsp;&emsp;多: 试用场景多&emsp;&emsp;快: 环境部署快，更新快&emsp;&emsp;好: 好多人在用，东西好&emsp;&emsp;省: 省钱省力省人工 缺点:&emsp;&emsp;太腻歪人: 依赖操作系统&emsp;&emsp;不善于沟通: 依赖网络&emsp;&emsp;无法使用外部硬件","categories":[{"name":"运维之路","slug":"运维之路","permalink":"https://ewedwc.github.io/categories/运维之路/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://ewedwc.github.io/tags/docker/"}],"keywords":[{"name":"运维之路","slug":"运维之路","permalink":"https://ewedwc.github.io/categories/运维之路/"}]},{"title":"Python输出各类三角形","slug":"Python输出各类三角形","date":"2018-11-13T10:50:34.000Z","updated":"2018-11-13T14:31:59.377Z","comments":true,"path":"categories/db7c6f16.html","link":"","permalink":"https://ewedwc.github.io/categories/db7c6f16.html","excerpt":"","text":"Python输出各类三角形 今天面试被问了这个问题先将这类问题做个总结 1.打印左下角三角形：代码如下: 12345678910111213141516for i in range(n): for j in range(0,i): print(&quot;*&quot;end=&quot; &quot;) for k in range(i,n): print(&quot; &quot;,end=&quot; &quot;) print(&quot;&quot;) * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 2.打印右上角三角形：代码如下: 1234567891011121314151617for i in range(n): for j in range(0,i): print(&quot; &quot;,end=&quot; &quot;) for k in range(i,n): print(&quot;*&quot;,end=&quot; &quot;) print(&quot; &quot;) * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 3.打印等腰三角形代码如下: 12345678910111213141516171819def A(n): for i in range(n): for j in range(0, i): print(end=&quot; &quot;) for k in range(i, n): print(&quot;*&quot;, end=&quot; &quot;) print(&quot;&quot;)A(10) * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 4.打印等腰三角形代码如下: 1234567891011121314151617def A(n): for i in range(n): for j range(0,n-i): print(ent=&quot; &quot;) for k range(n-i,n): print(&quot;*&quot;,ent=&quot; &quot;) print(&quot;&quot;) * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *","categories":[{"name":"Python开发","slug":"Python开发","permalink":"https://ewedwc.github.io/categories/Python开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://ewedwc.github.io/tags/Python/"}],"keywords":[{"name":"Python开发","slug":"Python开发","permalink":"https://ewedwc.github.io/categories/Python开发/"}]},{"title":"冒泡排序","slug":"冒泡排序","date":"2018-11-13T09:40:17.000Z","updated":"2018-11-13T10:45:28.524Z","comments":true,"path":"categories/14e6f1eb.html","link":"","permalink":"https://ewedwc.github.io/categories/14e6f1eb.html","excerpt":"","text":"冒泡排序 冒泡排序的思想：每次比较两个相邻的元素，如果它们前一个比后一个大就交换俩个元素的位置，如果后一个元素比前一个元素大不处理。 代码思想:利用两个for循环进行操作，第一个for循环记录循环次数，第二个循环列表中未归位的最大的元素，已经归位的元素不再参与比较。 Python代码实现123456789#!/usr/bin/env Pythondef bubbleSort(nums) for i in range(len(nums)-1) for j in range(len(nums)-i-1) if nums[j]&gt;nums[j+1] nums[j],num[j+1] = nums[j+1],num[j] return numsnums = [5,2,4,1,6,1]print (bubbleSort(nums))","categories":[{"name":"Python开发","slug":"Python开发","permalink":"https://ewedwc.github.io/categories/Python开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://ewedwc.github.io/tags/Python/"},{"name":"算法","slug":"算法","permalink":"https://ewedwc.github.io/tags/算法/"}],"keywords":[{"name":"Python开发","slug":"Python开发","permalink":"https://ewedwc.github.io/categories/Python开发/"}]},{"title":"Python青蛙跳台阶问题","slug":"Python青蛙跳台阶问题","date":"2018-10-15T03:02:31.000Z","updated":"2018-11-15T04:39:06.421Z","comments":true,"path":"categories/d9104bdb.html","link":"","permalink":"https://ewedwc.github.io/categories/d9104bdb.html","excerpt":"","text":"1.斐波那契数列 斐波那契数列即著名的兔子数列：1、1、2、3、5、8、13、21、34、……数列特点：该数列从第三项开始，每个数的值为其前两个数之和，用python实现起来很简单： 12345a = 0b = 1while b&lt;1000: print(b) a,b = b,a+b 利用递归实现斐波那契数列前n项 1234567lis = []for i in range(20) if i ==0 or i ==1: lis.append(1) else: lis.append(list[i-2]+list[i-1])print(lis) 2.青蛙跳台阶问题，一只青蛙要跳上n层高的台阶，一次能跳一级，也可以跳两级，请问这只青蛙有多少种跳上这个n层高台阶的方法？ 方法1:递归 12345678class Solution: def climbStairs(self,n): if n ==1: return 1 elif n == 2: return 2 else: return self.climbStairs(n-1)+self.climbStairs(n-2) 方法2:用循环来替代递归 这种方法的原理仍然基于上面的公式，但是用循环代替了递归，比上面的代码效率上有较大的提升，可以AC代码实现如下： 12345678class Solution: def climbStairs(self,n) if n ==1 or n ==2: return n a=1;b=2;c=3 for i in range(3,n+1) c = a+b;a=b;b=c return c 方法3:建立简单的数学模型，利用数学公式 12345678910111213class Solution: # @param &#123;integer&#125; n # @return &#123;integer&#125; def climbStairs(self, n): def fact(n): result=1 for i in range(1,n+1): result*=i return result total=0 for i in range(n/2+1): total+=fact(i+n-2*i)/fact(i)/fact(n-2*i) return total 3.一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 代码实现:1234def jump_floor(number): if number == 0: return 0 return 2**(number-1)","categories":[{"name":"Python开发","slug":"Python开发","permalink":"https://ewedwc.github.io/categories/Python开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://ewedwc.github.io/tags/Python/"},{"name":"算法","slug":"算法","permalink":"https://ewedwc.github.io/tags/算法/"}],"keywords":[{"name":"Python开发","slug":"Python开发","permalink":"https://ewedwc.github.io/categories/Python开发/"}]},{"title":"Python垃圾回收机制","slug":"Python垃圾回收机制","date":"2018-10-10T14:26:35.000Z","updated":"2018-11-15T15:32:36.295Z","comments":true,"path":"categories/2fca497a.html","link":"","permalink":"https://ewedwc.github.io/categories/2fca497a.html","excerpt":"","text":"Python垃圾回收机制&emsp;&emsp;GC作为现代编程语言的自动内存管理机制，专注于两件事:1.找到内存中无用的垃圾资源。2.清除这些垃圾并把内存让出来给其他对象使用。GC彻底把程序从资源管理的重担中解放出来，让他们有更多的时间放在业务逻辑上。但这并不意味我们可以不去了解GC，毕竟了解了GC知识还是有利于我们代码的健壮性。 1.引用计数器&emsp;&emsp;Python语言默认采用的垃圾回收机制是“引用计数器法”，该算法依然是被很多编程语言使用，「引用计数器法」的原理是每个对象维护一个ob_ref字段，用来记录该对象的当前被引用的次数，每当新的引用指向该对象是，它的引用计数ob_ref加1，每当该对象的当前引用失效时计数ob_ref减1，一旦对象的引用计数为0，该对象立即被收回，对象占用的内存空间将被释放。它的缺点是需要额外的空间维护引用计数，这个问题是其次的，不过最主要的问题是他不能解决对象的“循环引用”，因此，也有很多语言比如java并没有采用该算法来做垃圾回收机制。&emsp;&emsp;什么是循环引用？A和B相互引用而在没有外部引用A与B中的任何一个，它们的引用计数器虽然都为1，但显然应该被回收，因此使用了引用计数器来管理这两个对象的话，它们并不会被回收，它们会一直驻留在内存中，就会造成内存泄漏（内存空间在使用完毕后为释放）。为了未解决对象的循环引用问题，Python引入了标记-清除和分代回收两种GC机制。 2.标记清除&emsp;&emsp;「标记清除（Mark-Sweep）」算法是一种基于追踪回收（tracing GC）技术实现的垃圾回收算法。它分为两个阶段:第一阶段是标记阶段，GC会把所有活动对象打上标记，第二阶段是把那些没有标记的对象「非活动对象」进行回收。那么GC又是如何判断那些是活动对象那些是非活动对象的呢？&emsp;&emsp;对象之间通过引用（指针）连在一起，构成一个有相图，对象构成这个有相图的节点，而引用关系构成这个有相图的边。从根对象出发，沿着有向边遍历对象，可达的对象标记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。&emsp;&emsp;标记清除算法作为Python的辅助垃圾收集技术主要处理的是一些容器对象，比如list、dict、tuple，instance等，因为对于字符串、数值对象是不可能造成循环引用问题。Python使用一个双向链表将这些容器对象组织起来。不过，这种简单粗暴的标记清除算法也有明显的缺点：清除非活动的对象前它必须顺序扫描整个堆内存，哪怕只剩下小部分活动对象也要扫描所有对象。 3.分代回收&emsp;&emsp;分代回收是一种以空间换时间的操作方式，Python将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代，Python将内存分为了3“代”，分别为年轻代（第0代）、中年代（第1代）、老年代（第2代），他们对应的是3个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python垃圾收集机制就会被触发，把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去，依此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。同时，分代回收是建立在标记清除技术基础之上。分代回收同样作为Python的辅助垃圾收集技术处理那些容器对象","categories":[{"name":"Python开发","slug":"Python开发","permalink":"https://ewedwc.github.io/categories/Python开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://ewedwc.github.io/tags/Python/"}],"keywords":[{"name":"Python开发","slug":"Python开发","permalink":"https://ewedwc.github.io/categories/Python开发/"}]},{"title":"Python常用技巧","slug":"Python常用技巧","date":"2018-10-01T09:52:52.000Z","updated":"2018-11-14T17:16:42.419Z","comments":true,"path":"categories/ed00236b.html","link":"","permalink":"https://ewedwc.github.io/categories/ed00236b.html","excerpt":"","text":"1.1拆箱123456789101112131415161718&gt;&gt;&gt; a,b,c = 1,2,3&gt;&gt;&gt; a,b,c(1,2,3)&gt;&gt;&gt; a,b,c = [1,2,3]&gt;&gt;&gt; a,b,c[1,2,3]&gt;&gt;&gt; a,b,c = (2*i+1 in range(3))&gt;&gt;&gt; a,b,c(1,3,5)&gt;&gt;&gt; a,(b,c),d = [1,(2,3),4]&gt;&gt;&gt; a1&gt;&gt;&gt; b2&gt;&gt;&gt; c3&gt;&gt;&gt; d4 1.2拆箱变量交换1234&gt;&gt;&gt; a,b = 1,2&gt;&gt;&gt; a,b = b,a&gt;&gt;&gt; a,b(2,1) 1.3扩展拆箱（只兼容Python3）1234567&gt;&gt;&gt; a,*b,c = [1,2,3,4,5]&gt;&gt;&gt; a1&gt;&gt;&gt; b[2,3,4]&gt;&gt;&gt; c5 1.4 切割列表123&gt;&gt;&gt; a = [0,1,2,3,4,5,6,7,8,9,10]&gt;&gt;&gt; a[2:8][2,3,4,5,6,7] 1.5 负数索引切割列表123&gt;&gt;&gt; a = [0,1,2,3,4,5,6,7,8,9,10]&gt;&gt;&gt; a[-4,-2][7,8] 1.6指定步长切割列表1234567&gt;&gt;&gt; a = [0,1,2,3,4,5,6,7,8,9,10]&gt;&gt;&gt; a[::2][0,2,4,6,8,10]&gt;&gt;&gt; a[::3][0,3,6,9]&gt;&gt;&gt; a[2:8:2][2,4,6] 1.7负数步长切割列表12345&gt;&gt;&gt; a = [0,1,2,3,4,5,6,7,8,9,10]&gt;&gt;&gt; a =[::-1][10,9,8,7,6,5,4,3,2,1,0]&gt;&gt;&gt; a[::-2][10,8,6,4,2,0] 1.8列表切割赋值12345678910&gt;&gt;&gt; a = [1,2,3,4,5]&gt;&gt;&gt; a[2:3] = [0,0]&gt;&gt;&gt; a[1,2,0,0,4,5]&gt;&gt;&gt; a[1:1] = [8,9]&gt;&gt;&gt; a[1,8,9,2,0,0,4,5]&gt;&gt;&gt; a[1:-1] = []&gt;&gt;&gt; a[1,5] 1.9 命名列表切割方式123456&gt;&gt;&gt; a = [0,1,2,3,4,5]&gt;&gt;&gt; LASTTHERE = slice(-3,None)&gt;&gt;&gt; LASTTHEREslice(-3,None,None)&gt;&gt;&gt; a [LASTTHERE][3,4,5] 1.10 列表以及迭代器的压缩和解压缩1234567&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; b = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]&gt;&gt;&gt; z = zip(a,b)&gt;&gt;&gt; z[(1,&apos;a&apos;),(2,&apos;b&apos;),(3,&apos;c&apos;)]&gt;&gt;&gt; zip(*z)[(1,2,3),(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;)] 1.11 列表相邻元素压缩器1234567891011121314151617&gt;&gt;&gt; a = [1,2,3,4,5,6]&gt;&gt;&gt; zip(*([iter(a)]*2))[(1,2),(3,4),(5,6)]&gt;&gt;&gt; group_adjacent = lambda a, k: zip(*([iter(a)]*k))&gt;&gt;&gt; group_adjacent(a,3)[(1,2,3),(4,5,6)]&gt;&gt;&gt; group_adjacent(a,1)[(1,),(2,),(3,),(4,),(5,),(6,)]&gt;&gt;&gt; zip(a[::2],a[1::3],a[2::3])[(1, 2, 3), (4, 5, 6)]&gt;&gt;&gt; group_adjacent = lambda a,k:zip(*(a[i:k] for i in range(k)))&gt;&gt;&gt; group_adjacent(a,3)[(1, 2, 3), (4, 5, 6)]&gt;&gt;&gt; group_adjacent(a,2)[(1, 2), (3, 4), (5, 6)]&gt;&gt;&gt; group_adjacent(a, 1)[(1,), (2,), (3,), (4,), (5,), (6,)] 1.12 在列表中用压缩器和迭代器滑动取值窗口1234567891011&gt;&gt;&gt; def n_grams(a, n):... z = [iter(a[i:]) for i in range(n)]... return zip(*z)...&gt;&gt;&gt; a = [1, 2, 3, 4, 5, 6]&gt;&gt;&gt; n_grams(a, 3)[(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6)]&gt;&gt;&gt; n_grams(a, 2)[(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]&gt;&gt;&gt; n_grams(a, 4)[(1, 2, 3, 4), (2, 3, 4, 5), (3, 4, 5, 6)] 1.13 用压缩器反转字典12345678&gt;&gt;&gt; m = &#123;&apos;a&apos;: 1, &apos;b&apos;: 2, &apos;c&apos;: 3, &apos;d&apos;: 4&#125;&gt;&gt;&gt; m.items()[(&apos;a&apos;, 1), (&apos;c&apos;, 3), (&apos;b&apos;, 2), (&apos;d&apos;, 4)]&gt;&gt;&gt; zip(m.values(), m.keys())[(1, &apos;a&apos;), (3, &apos;c&apos;), (2, &apos;b&apos;), (4, &apos;d&apos;)]&gt;&gt;&gt; mi = dict(zip(m.values(), m.keys()))&gt;&gt;&gt; mi&#123;1: &apos;a&apos;, 2: &apos;b&apos;, 3: &apos;c&apos;, 4: &apos;d&apos;&#125; 1.14 列表的展开1234567&gt;&gt;&gt; a = [[1, 2], [3, 4], [5, 6]]&gt;&gt;&gt; list(itertools.chain.from_iterable(a))[1, 2, 3, 4, 5, 6]&gt;&gt;&gt; sum(a, [])[1, 2, 3, 4, 5, 6]&gt;&gt;&gt; [x for l in a for x in l][1, 2, 3, 4, 5, 6] 1.15 生成器表达式12345678910111213&gt;&gt;&gt; g = (x ** 2 for x in xrange(10))&gt;&gt;&gt; next(g)0&gt;&gt;&gt; next(g)1&gt;&gt;&gt; next(g)4&gt;&gt;&gt; next(g)9&gt;&gt;&gt; sum(x ** 3 for x in xrange(10))2025&gt;&gt;&gt; sum(x ** 3 for x in xrange(10) if x % 3 == 1)408 1.16 字典推导式1234567&gt;&gt;&gt; m = &#123;x: x ** 2 for x in range(5)&#125;&gt;&gt;&gt; m&#123;0: 0, 1: 1, 2: 4, 3: 9, 4: 16&#125;&gt;&gt;&gt; m = &#123;x: &apos;A&apos; + str(x) for x in range(10)&#125;&gt;&gt;&gt; m&#123;0: &apos;A0&apos;, 1: &apos;A1&apos;, 2: &apos;A2&apos;, 3: &apos;A3&apos;, 4: &apos;A4&apos;, 5: &apos;A5&apos;, 6: &apos;A6&apos;, 7: &apos;A7&apos;, 8: &apos;A8&apos;, 9: &apos;A9&apos;&#125; 1.17 字典反转推导式12345&gt;&gt;&gt; m = &#123;&apos;a&apos;: 1, &apos;b&apos;: 2, &apos;c&apos;: 3, &apos;d&apos;: 4&#125;&gt;&gt;&gt; m&#123;&apos;d&apos;: 4, &apos;a&apos;: 1, &apos;b&apos;: 2, &apos;c&apos;: 3&#125;&gt;&gt;&gt; &#123;v: k for k, v in m.items()&#125;&#123;1: &apos;a&apos;, 2: &apos;b&apos;, 3: &apos;c&apos;, 4: &apos;d&apos;&#125;","categories":[{"name":"Python开发","slug":"Python开发","permalink":"https://ewedwc.github.io/categories/Python开发/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://ewedwc.github.io/tags/Python/"}],"keywords":[{"name":"Python开发","slug":"Python开发","permalink":"https://ewedwc.github.io/categories/Python开发/"}]},{"title":"Linux中find命令用法全汇总","slug":"Linux中find命令用法全汇总","date":"2018-09-15T07:50:24.000Z","updated":"2018-11-15T13:22:52.465Z","comments":true,"path":"categories/da44e512.html","link":"","permalink":"https://ewedwc.github.io/categories/da44e512.html","excerpt":"","text":"第一部分:查找名称查找文件的基本查找命令 1.使用当前目录中的名称查找文件在当前工作目录中查找名称为test.c的所有文件。 12&gt;&gt;&gt;find test.ctest.c 2.在主目录下查找文件查找/home目录下的所有文件，名称为test。 123&gt;&gt;&gt;find /home -name test#无权限目录不进行查找/home/neil/Code/test 3.使用名称或忽略案例查找文件找到名称为test的所有文件，并在/home目录中同时包含大写和小写字母。 1234&gt;&gt;&gt;find /home -iname test#-i 忽略大小写/home/neil/Code/test/home/neil/Code/Test 4.使用名称按类型查找在/目录中查找名称为test的所有目录。 1&gt;&gt;&gt;find / -type d -name test 在当前文件中查找名称为test.php的文件 1&gt;&gt;&gt;find -type f -name test.php 第二部分:根据他们的权限查找文件 5.查找777的权限的文件查找权限为777 的所有文件 12&gt;&gt;&gt;find -type f -perm 777 -print#-print 格式化输出在文件的名前面加./ 查找所有文件没有777权限的文件 1&gt;&gt;&gt;find / -type f ! -perm 777 6.查找具有644的权限的SGID文件查找权限设置为644的所有SGID位的文件 1&gt;&gt;&gt;find / -perm 2644 7.查找具有551权限的粘滞位文件。查找权限为511的所有sticky Bit设置文件。 1&gt;&gt;&gt;find / -perm 1551 8.查找SUID文件查找所有SUID集文件。 1&gt;&gt;&gt;finde / -perm /u=s 9.查找只读文件查找所有只读文件。 1&gt;&gt;&gt;find / -perm /u=r 10.查找可执行文件查找所有可执行文件 1&gt;&gt;&gt;find / -perm /a=x 11.找到777的权限和chmod到644的文件查找所有777的权限文件，并使用chmod命令将权限设置为644 1234&gt;&gt;&gt;find / -type f -perm 0777 -print -exec chmod 644 &#123;&#125; \\;#-exec 将前面产生的结果当成参数一个一个的传给后面的命令执行#-args 将前面产生的结果当成参数一次性穿个后面的命令执行，不过可以用 -n指定个数#|前面命令的标准输出，当成后面命令的标准输入 12.找到具有777的权限的目录和chmod到755查找所有777的权限的目录，并使chmod 命令将权限设置为755 1&gt;&gt;&gt;find / -type d -perm 777 -print -exec chmod 755 &#123;&#125; \\; 13.查找并删除多个文件查找和删除多个文件，如.mp3或.txt,然后使用。 12&gt;&gt;&gt;find -type f -name &quot;*.txt&quot; -exec rm -f &#123;&#125; \\;&gt;&gt;&gt;find -type f -name &quot;*.mp3&quot; -exec rm -f &#123;&#125; \\; 14.查找所有空文件和目录在特定路径下查找所用空文件 1&gt;&gt;&gt;find /tmp -type f -empty 在特定路径下的空目录归档 1&gt;&gt;&gt;find /tmp -type d -empty 15.查找所有隐藏文件查找所有隐藏的文件，请使用以下命令。 1&gt;&gt;&gt;find /tmp -type f -name &quot;.*&quot; 第三部分:基于所有者和组的搜索文件 16.查找基于用户的单个文件在所有者root的/root 目录下查找名为test.c的所有或单个文件。 1&gt;&gt;&gt;find / -user root -name test.c 17.查找基于用户和组的所有文件。查找～目录下属于用户neil的所有文件 1&gt;&gt;&gt;find ~ -user neil 查找/home目录下属于Group Developer的所有文件。 1&gt;&gt;&gt;find /home -group Developer 18.查找用户的特定文件查找～目录下用户neil的所有.txt文件 1&gt;&gt;&gt;find ~ -user neil -iname &quot;*.c&quot; 第四部分: 根据日期和时间查找文件和目录 19.查找50天后访问的所有文件。查找50天后访问的所有文件。 1&gt;&gt;&gt;find / -atime 50 20.查找最后50-100天修改的文件查找所有被修改超过50天以及少于100天的文件。 1&gt;&gt;&gt;find / -mtime +50 -mtime -100 21.在过去1小时内更改的所有文件 1&gt;&gt;&gt;find /cmin -60 22.查找在最近一小时内更改的所有文件 1&gt;&gt;&gt;find / -mtime -60 22.查找最近1小时内访问的文件 1&gt;&gt;&gt;find / -amin -60 第五部分: 根据大小查找文件和目录 23.找的50MB的文件 1&gt;&gt;&gt;find /-size 50M 24.查找大小在50M到100M之间的所有文件 1&gt;&gt;&gt;find / -size +50M -size -100M 25.查找并删除100MB的文件 1&gt;&gt;&gt;find / -size 100M -exec rm -rf &#123;&#125; \\; 26.查找特定文件并删除 1&gt;&gt;&gt;find / -type f -name *.mp3 -size +10M -exec rm &#123;&#125; \\;","categories":[{"name":"Linux基础","slug":"Linux基础","permalink":"https://ewedwc.github.io/categories/Linux基础/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://ewedwc.github.io/tags/Linux/"}],"keywords":[{"name":"Linux基础","slug":"Linux基础","permalink":"https://ewedwc.github.io/categories/Linux基础/"}]}]}