{"meta":{"title":"超哥博客","subtitle":"打造码农的世界","description":null,"author":"Dingchao.Wu","url":"https://ewedwc.github.io"},"pages":[],"posts":[{"title":"Docker基础","slug":"Docker基础","date":"2018-11-14T02:52:58.000Z","updated":"2018-11-15T07:34:55.163Z","comments":true,"path":"categories/1d9fbb6a.html","link":"","permalink":"https://ewedwc.github.io/categories/1d9fbb6a.html","excerpt":"","text":"1.安装Docker linux安装Docker12345678#安装curl命令sudo apt-get install curl#安装Dockercurl -fsSl https://get.Docker.com |sh#检查Dockersudo docker version#将当前用户添加到docker组中免敲sudo命令sudo useradd -aG docker 当前用户名 1234567#使用不同的的源 官方源: curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) st able&quot;阿里云的源&#123;推荐&#125; curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add - add-apt-repository &quot;deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_relea se -cs) stable&quot; Mac安装Docker 1官网下载Docker for Mac 进行安装 Docker 删除 123apt-get purge docke-ce -yrm -rf /var/lib/docer/rm - rf /etc/docker Docker加速器&emsp;&emsp;在国内使用docker的官方镜像源，会因为网络的原因，造成无法下载，或者一直处于超时。所以我们使用 daocloud 的方法进行加速配置。 2.Docker介绍 Docker是什么Docker是一个开源的容器引擎，它基于LXC（LXC又名Linux container，是一种虚拟化的解决方案，这种是内核级的虚拟化。(主流的解决方案Xen ,KVM, LXC)）容器技术，使用GO语言开发。遵循Apache2.0协议。Docker采用C/S架构，其可以为任何应用创建一个轻量级、可移植的、自给自足的容器。Docker就是一种快速解决生产问题的一种技术手段。 Docker的特点 三大理念：构建:&emsp;&emsp;将你需要的场景构建好，装在一个镜像中，就好比龙珠中的胶囊一样。运输:&emsp;&emsp;随身携带非常方便运行:&emsp;&emsp;只要在需要的地方一放，打开使用就OK了 优点:&emsp;&emsp;多: 试用场景多&emsp;&emsp;快: 环境部署快，更新快&emsp;&emsp;好: 好多人在用，东西好&emsp;&emsp;省: 省钱省力省人工 缺点:&emsp;&emsp;太腻歪人: 依赖操作系统&emsp;&emsp;不善于沟通: 依赖网络&emsp;&emsp;无法使用外部硬件","categories":[{"name":"运维之路","slug":"运维之路","permalink":"https://ewedwc.github.io/categories/运维之路/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://ewedwc.github.io/tags/docker/"}],"keywords":[{"name":"运维之路","slug":"运维之路","permalink":"https://ewedwc.github.io/categories/运维之路/"}]},{"title":"Python输出各类三角形","slug":"Python输出各类三角形","date":"2018-11-13T10:50:34.000Z","updated":"2018-11-17T05:39:17.244Z","comments":true,"path":"categories/db7c6f16.html","link":"","permalink":"https://ewedwc.github.io/categories/db7c6f16.html","excerpt":"","text":"Python输出各类三角形 今天面试被问了这个问题先将这类问题做个总结 1.打印左下角三角形：代码如下: 12345678910111213141516for i in range(n): for j in range(0,i): print(&quot;*&quot;end=&quot; &quot;) for k in range(i,n): print(&quot; &quot;,end=&quot; &quot;) print(&quot;&quot;) * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 2.打印右上角三角形：代码如下: 1234567891011121314151617for i in range(n): for j in range(0,i): print(&quot; &quot;,end=&quot; &quot;) for k in range(i,n): print(&quot;*&quot;,end=&quot; &quot;) print(&quot; &quot;) * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 3.打印等腰三角形代码如下: 12345678910111213141516171819def A(n): for i in range(n): for j in range(0, i): print(end=&quot; &quot;) for k in range(i, n): print(&quot;*&quot;, end=&quot; &quot;) print(&quot;&quot;)A(10) * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 4.打印等腰三角形代码如下: 1234567891011121314151617def A(n): for i in range(n): for j range(0,n-i): print(ent=&quot; &quot;) for k range(n-i,n): print(&quot;*&quot;,ent=&quot; &quot;) print(&quot;&quot;) * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *","categories":[{"name":"Python开发","slug":"Python开发","permalink":"https://ewedwc.github.io/categories/Python开发/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ewedwc.github.io/tags/python/"}],"keywords":[{"name":"Python开发","slug":"Python开发","permalink":"https://ewedwc.github.io/categories/Python开发/"}]},{"title":"冒泡排序","slug":"冒泡排序","date":"2018-11-13T09:40:17.000Z","updated":"2018-11-17T05:39:13.065Z","comments":true,"path":"categories/14e6f1eb.html","link":"","permalink":"https://ewedwc.github.io/categories/14e6f1eb.html","excerpt":"","text":"冒泡排序 冒泡排序的思想：每次比较两个相邻的元素，如果它们前一个比后一个大就交换俩个元素的位置，如果后一个元素比前一个元素大不处理。 代码思想:利用两个for循环进行操作，第一个for循环记录循环次数，第二个循环列表中未归位的最大的元素，已经归位的元素不再参与比较。 Python代码实现123456789#!/usr/bin/env Pythondef bubbleSort(nums) for i in range(len(nums)-1) for j in range(len(nums)-i-1) if nums[j]&gt;nums[j+1] nums[j],num[j+1] = nums[j+1],num[j] return numsnums = [5,2,4,1,6,1]print (bubbleSort(nums))","categories":[{"name":"Python开发","slug":"Python开发","permalink":"https://ewedwc.github.io/categories/Python开发/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://ewedwc.github.io/tags/算法/"},{"name":"python","slug":"python","permalink":"https://ewedwc.github.io/tags/python/"}],"keywords":[{"name":"Python开发","slug":"Python开发","permalink":"https://ewedwc.github.io/categories/Python开发/"}]},{"title":"Python青蛙跳台阶问题","slug":"Python青蛙跳台阶问题","date":"2018-10-15T03:02:31.000Z","updated":"2018-11-17T05:39:15.142Z","comments":true,"path":"categories/d9104bdb.html","link":"","permalink":"https://ewedwc.github.io/categories/d9104bdb.html","excerpt":"","text":"1.斐波那契数列 斐波那契数列即著名的兔子数列：1、1、2、3、5、8、13、21、34、……数列特点：该数列从第三项开始，每个数的值为其前两个数之和，用python实现起来很简单： 12345a = 0b = 1while b&lt;1000: print(b) a,b = b,a+b 利用递归实现斐波那契数列前n项 1234567lis = []for i in range(20) if i ==0 or i ==1: lis.append(1) else: lis.append(list[i-2]+list[i-1])print(lis) 2.青蛙跳台阶问题，一只青蛙要跳上n层高的台阶，一次能跳一级，也可以跳两级，请问这只青蛙有多少种跳上这个n层高台阶的方法？ 方法1:递归 12345678class Solution: def climbStairs(self,n): if n ==1: return 1 elif n == 2: return 2 else: return self.climbStairs(n-1)+self.climbStairs(n-2) 方法2:用循环来替代递归 这种方法的原理仍然基于上面的公式，但是用循环代替了递归，比上面的代码效率上有较大的提升，可以AC代码实现如下： 12345678class Solution: def climbStairs(self,n) if n ==1 or n ==2: return n a=1;b=2;c=3 for i in range(3,n+1) c = a+b;a=b;b=c return c 方法3:建立简单的数学模型，利用数学公式 12345678910111213class Solution: # @param &#123;integer&#125; n # @return &#123;integer&#125; def climbStairs(self, n): def fact(n): result=1 for i in range(1,n+1): result*=i return result total=0 for i in range(n/2+1): total+=fact(i+n-2*i)/fact(i)/fact(n-2*i) return total 3.一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 代码实现:1234def jump_floor(number): if number == 0: return 0 return 2**(number-1)","categories":[{"name":"Python开发","slug":"Python开发","permalink":"https://ewedwc.github.io/categories/Python开发/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://ewedwc.github.io/tags/算法/"},{"name":"python","slug":"python","permalink":"https://ewedwc.github.io/tags/python/"}],"keywords":[{"name":"Python开发","slug":"Python开发","permalink":"https://ewedwc.github.io/categories/Python开发/"}]},{"title":"Python垃圾回收机制","slug":"Python垃圾回收机制","date":"2018-10-10T14:26:35.000Z","updated":"2018-11-17T05:39:23.868Z","comments":true,"path":"categories/2fca497a.html","link":"","permalink":"https://ewedwc.github.io/categories/2fca497a.html","excerpt":"","text":"Python垃圾回收机制&emsp;&emsp;GC作为现代编程语言的自动内存管理机制，专注于两件事:1.找到内存中无用的垃圾资源。2.清除这些垃圾并把内存让出来给其他对象使用。GC彻底把程序从资源管理的重担中解放出来，让他们有更多的时间放在业务逻辑上。但这并不意味我们可以不去了解GC，毕竟了解了GC知识还是有利于我们代码的健壮性。 1.引用计数器&emsp;&emsp;Python语言默认采用的垃圾回收机制是“引用计数器法”，该算法依然是被很多编程语言使用，「引用计数器法」的原理是每个对象维护一个ob_ref字段，用来记录该对象的当前被引用的次数，每当新的引用指向该对象是，它的引用计数ob_ref加1，每当该对象的当前引用失效时计数ob_ref减1，一旦对象的引用计数为0，该对象立即被收回，对象占用的内存空间将被释放。它的缺点是需要额外的空间维护引用计数，这个问题是其次的，不过最主要的问题是他不能解决对象的“循环引用”，因此，也有很多语言比如java并没有采用该算法来做垃圾回收机制。&emsp;&emsp;什么是循环引用？A和B相互引用而在没有外部引用A与B中的任何一个，它们的引用计数器虽然都为1，但显然应该被回收，因此使用了引用计数器来管理这两个对象的话，它们并不会被回收，它们会一直驻留在内存中，就会造成内存泄漏（内存空间在使用完毕后为释放）。为了未解决对象的循环引用问题，Python引入了标记-清除和分代回收两种GC机制。 2.标记清除&emsp;&emsp;「标记清除（Mark-Sweep）」算法是一种基于追踪回收（tracing GC）技术实现的垃圾回收算法。它分为两个阶段:第一阶段是标记阶段，GC会把所有活动对象打上标记，第二阶段是把那些没有标记的对象「非活动对象」进行回收。那么GC又是如何判断那些是活动对象那些是非活动对象的呢？&emsp;&emsp;对象之间通过引用（指针）连在一起，构成一个有相图，对象构成这个有相图的节点，而引用关系构成这个有相图的边。从根对象出发，沿着有向边遍历对象，可达的对象标记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。&emsp;&emsp;标记清除算法作为Python的辅助垃圾收集技术主要处理的是一些容器对象，比如list、dict、tuple，instance等，因为对于字符串、数值对象是不可能造成循环引用问题。Python使用一个双向链表将这些容器对象组织起来。不过，这种简单粗暴的标记清除算法也有明显的缺点：清除非活动的对象前它必须顺序扫描整个堆内存，哪怕只剩下小部分活动对象也要扫描所有对象。 3.分代回收&emsp;&emsp;分代回收是一种以空间换时间的操作方式，Python将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代，Python将内存分为了3“代”，分别为年轻代（第0代）、中年代（第1代）、老年代（第2代），他们对应的是3个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python垃圾收集机制就会被触发，把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去，依此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。同时，分代回收是建立在标记清除技术基础之上。分代回收同样作为Python的辅助垃圾收集技术处理那些容器对象","categories":[{"name":"Python开发","slug":"Python开发","permalink":"https://ewedwc.github.io/categories/Python开发/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ewedwc.github.io/tags/python/"}],"keywords":[{"name":"Python开发","slug":"Python开发","permalink":"https://ewedwc.github.io/categories/Python开发/"}]},{"title":"Python常用技巧","slug":"Python常用技巧","date":"2018-10-01T09:52:52.000Z","updated":"2018-11-17T05:39:21.700Z","comments":true,"path":"categories/ed00236b.html","link":"","permalink":"https://ewedwc.github.io/categories/ed00236b.html","excerpt":"","text":"1.1拆箱123456789101112131415161718&gt;&gt;&gt; a,b,c = 1,2,3&gt;&gt;&gt; a,b,c(1,2,3)&gt;&gt;&gt; a,b,c = [1,2,3]&gt;&gt;&gt; a,b,c[1,2,3]&gt;&gt;&gt; a,b,c = (2*i+1 in range(3))&gt;&gt;&gt; a,b,c(1,3,5)&gt;&gt;&gt; a,(b,c),d = [1,(2,3),4]&gt;&gt;&gt; a1&gt;&gt;&gt; b2&gt;&gt;&gt; c3&gt;&gt;&gt; d4 1.2拆箱变量交换1234&gt;&gt;&gt; a,b = 1,2&gt;&gt;&gt; a,b = b,a&gt;&gt;&gt; a,b(2,1) 1.3扩展拆箱（只兼容Python3）1234567&gt;&gt;&gt; a,*b,c = [1,2,3,4,5]&gt;&gt;&gt; a1&gt;&gt;&gt; b[2,3,4]&gt;&gt;&gt; c5 1.4 切割列表123&gt;&gt;&gt; a = [0,1,2,3,4,5,6,7,8,9,10]&gt;&gt;&gt; a[2:8][2,3,4,5,6,7] 1.5 负数索引切割列表123&gt;&gt;&gt; a = [0,1,2,3,4,5,6,7,8,9,10]&gt;&gt;&gt; a[-4,-2][7,8] 1.6指定步长切割列表1234567&gt;&gt;&gt; a = [0,1,2,3,4,5,6,7,8,9,10]&gt;&gt;&gt; a[::2][0,2,4,6,8,10]&gt;&gt;&gt; a[::3][0,3,6,9]&gt;&gt;&gt; a[2:8:2][2,4,6] 1.7负数步长切割列表12345&gt;&gt;&gt; a = [0,1,2,3,4,5,6,7,8,9,10]&gt;&gt;&gt; a =[::-1][10,9,8,7,6,5,4,3,2,1,0]&gt;&gt;&gt; a[::-2][10,8,6,4,2,0] 1.8列表切割赋值12345678910&gt;&gt;&gt; a = [1,2,3,4,5]&gt;&gt;&gt; a[2:3] = [0,0]&gt;&gt;&gt; a[1,2,0,0,4,5]&gt;&gt;&gt; a[1:1] = [8,9]&gt;&gt;&gt; a[1,8,9,2,0,0,4,5]&gt;&gt;&gt; a[1:-1] = []&gt;&gt;&gt; a[1,5] 1.9 命名列表切割方式123456&gt;&gt;&gt; a = [0,1,2,3,4,5]&gt;&gt;&gt; LASTTHERE = slice(-3,None)&gt;&gt;&gt; LASTTHEREslice(-3,None,None)&gt;&gt;&gt; a [LASTTHERE][3,4,5] 1.10 列表以及迭代器的压缩和解压缩1234567&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; b = [&apos;a&apos;,&apos;b&apos;,&apos;c&apos;]&gt;&gt;&gt; z = zip(a,b)&gt;&gt;&gt; z[(1,&apos;a&apos;),(2,&apos;b&apos;),(3,&apos;c&apos;)]&gt;&gt;&gt; zip(*z)[(1,2,3),(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;)] 1.11 列表相邻元素压缩器1234567891011121314151617&gt;&gt;&gt; a = [1,2,3,4,5,6]&gt;&gt;&gt; zip(*([iter(a)]*2))[(1,2),(3,4),(5,6)]&gt;&gt;&gt; group_adjacent = lambda a, k: zip(*([iter(a)]*k))&gt;&gt;&gt; group_adjacent(a,3)[(1,2,3),(4,5,6)]&gt;&gt;&gt; group_adjacent(a,1)[(1,),(2,),(3,),(4,),(5,),(6,)]&gt;&gt;&gt; zip(a[::2],a[1::3],a[2::3])[(1, 2, 3), (4, 5, 6)]&gt;&gt;&gt; group_adjacent = lambda a,k:zip(*(a[i:k] for i in range(k)))&gt;&gt;&gt; group_adjacent(a,3)[(1, 2, 3), (4, 5, 6)]&gt;&gt;&gt; group_adjacent(a,2)[(1, 2), (3, 4), (5, 6)]&gt;&gt;&gt; group_adjacent(a, 1)[(1,), (2,), (3,), (4,), (5,), (6,)] 1.12 在列表中用压缩器和迭代器滑动取值窗口1234567891011&gt;&gt;&gt; def n_grams(a, n):... z = [iter(a[i:]) for i in range(n)]... return zip(*z)...&gt;&gt;&gt; a = [1, 2, 3, 4, 5, 6]&gt;&gt;&gt; n_grams(a, 3)[(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6)]&gt;&gt;&gt; n_grams(a, 2)[(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]&gt;&gt;&gt; n_grams(a, 4)[(1, 2, 3, 4), (2, 3, 4, 5), (3, 4, 5, 6)] 1.13 用压缩器反转字典12345678&gt;&gt;&gt; m = &#123;&apos;a&apos;: 1, &apos;b&apos;: 2, &apos;c&apos;: 3, &apos;d&apos;: 4&#125;&gt;&gt;&gt; m.items()[(&apos;a&apos;, 1), (&apos;c&apos;, 3), (&apos;b&apos;, 2), (&apos;d&apos;, 4)]&gt;&gt;&gt; zip(m.values(), m.keys())[(1, &apos;a&apos;), (3, &apos;c&apos;), (2, &apos;b&apos;), (4, &apos;d&apos;)]&gt;&gt;&gt; mi = dict(zip(m.values(), m.keys()))&gt;&gt;&gt; mi&#123;1: &apos;a&apos;, 2: &apos;b&apos;, 3: &apos;c&apos;, 4: &apos;d&apos;&#125; 1.14 列表的展开1234567&gt;&gt;&gt; a = [[1, 2], [3, 4], [5, 6]]&gt;&gt;&gt; list(itertools.chain.from_iterable(a))[1, 2, 3, 4, 5, 6]&gt;&gt;&gt; sum(a, [])[1, 2, 3, 4, 5, 6]&gt;&gt;&gt; [x for l in a for x in l][1, 2, 3, 4, 5, 6] 1.15 生成器表达式12345678910111213&gt;&gt;&gt; g = (x ** 2 for x in xrange(10))&gt;&gt;&gt; next(g)0&gt;&gt;&gt; next(g)1&gt;&gt;&gt; next(g)4&gt;&gt;&gt; next(g)9&gt;&gt;&gt; sum(x ** 3 for x in xrange(10))2025&gt;&gt;&gt; sum(x ** 3 for x in xrange(10) if x % 3 == 1)408 1.16 字典推导式1234567&gt;&gt;&gt; m = &#123;x: x ** 2 for x in range(5)&#125;&gt;&gt;&gt; m&#123;0: 0, 1: 1, 2: 4, 3: 9, 4: 16&#125;&gt;&gt;&gt; m = &#123;x: &apos;A&apos; + str(x) for x in range(10)&#125;&gt;&gt;&gt; m&#123;0: &apos;A0&apos;, 1: &apos;A1&apos;, 2: &apos;A2&apos;, 3: &apos;A3&apos;, 4: &apos;A4&apos;, 5: &apos;A5&apos;, 6: &apos;A6&apos;, 7: &apos;A7&apos;, 8: &apos;A8&apos;, 9: &apos;A9&apos;&#125; 1.17 字典反转推导式12345&gt;&gt;&gt; m = &#123;&apos;a&apos;: 1, &apos;b&apos;: 2, &apos;c&apos;: 3, &apos;d&apos;: 4&#125;&gt;&gt;&gt; m&#123;&apos;d&apos;: 4, &apos;a&apos;: 1, &apos;b&apos;: 2, &apos;c&apos;: 3&#125;&gt;&gt;&gt; &#123;v: k for k, v in m.items()&#125;&#123;1: &apos;a&apos;, 2: &apos;b&apos;, 3: &apos;c&apos;, 4: &apos;d&apos;&#125;","categories":[{"name":"Python开发","slug":"Python开发","permalink":"https://ewedwc.github.io/categories/Python开发/"}],"tags":[{"name":"python","slug":"python","permalink":"https://ewedwc.github.io/tags/python/"}],"keywords":[{"name":"Python开发","slug":"Python开发","permalink":"https://ewedwc.github.io/categories/Python开发/"}]},{"title":"MySQL存储引擎详解","slug":"MySQL存储引擎详解","date":"2018-09-19T07:52:07.000Z","updated":"2018-11-25T08:42:07.506Z","comments":true,"path":"categories/7d23d68c.html","link":"","permalink":"https://ewedwc.github.io/categories/7d23d68c.html","excerpt":"","text":"什么是存储引擎？&emsp;&emsp;与其他数据库例如Oracle 和SQL Server等数据库中只有一种存储引擎不同的是，MySQL有一个被称为“Pluggable Storage Engine Architecture”(可替换存储引擎架构)的特性，也就意味着MySQL数据库提供了多种存储引擎。用户可以根据不同的需求为数据表选择不同的存储引擎，用户也可以根据自己的需要编写自己的存储引擎。MySQL数据库在实际的工作中其实分为了语句分析层和存储引擎层，其中语句分析层就主要负责与客户端完成连接并且事先分析出SQL语句的内容和功能，而存储引擎层则主要负责接收来自语句分析层的分析结果，完成相应的数据输入输出和文件操作。简而言之，就是如何存储数据、如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法。因为在关系数据库中数据的存储是以表的形式存储的，所以存储引擎也可以称为表类型（即存储和操作此表的类型）。 MySQL存储引擎种类 存储引擎 说明 MyISAM 高速引擎，拥有较高的插入，查询速度，但不支持事务 InnoDB 5.5版本后MySQL的默认数据库，支持事务和行级锁定，比MyISAM处理速度稍慢 ISAM MyISAM的前身，MySQL5.0以后不再默认安装 MRG_MyISAM（MERGE） 将多个表联合成一个表使用，在超大规模数据存储时很有用 Memory 内存存储引擎，拥有极高的插入，更新和查询效率。但是会占用和数据量成正比的内存空间。只在内存上保存数据，意味着数据可能会丢失 Falcon 一种新的存储引擎，支持事物处理，传言可能是InnoDB的替代者 Archive 将数据压缩后进行存储，非常适合存储大量的独立的，作为历史记录的数据，但是只能进行插入和查询操作 CSV CSV 存储引擎是基于 CSV 格式文件存储数据(应用于跨平台的数据交换) MyISAM 引擎&emsp;&emsp;这种引擎是MySQL最早提供的。这种引擎又可以分为静态MyISAM、动态MyISAM 和压缩MyISAM三种： 静态MyISAM：如果数据表中的各数据列的长度都是预先固定好的，服务器将自动选择这种表类型。因为数据表中每一条记录所占用的空间都是一样的，所以这种表存取和更新的效率非常高。当数据受损时，恢复工作也比较容易做。 动态MyISAM：如果数据表中出现varchar、xxxtext或xxxBLOB字段时，服务器将自动选择这种表类型。相对于静态MyISAM，这种表存储空间比较小，但由于每条记录的长度不一，所以多次修改数据后，数据表中的数据就可能离散的存储在内存中，进而导致执行效率下降。同时，内存中也可能会出现很多碎片。因此，这种类型的表要经常用optimize table 命令或优化工具来进行碎片整理。 mysql&gt; optimize table t1; #命令 优化工具:SQLAdvisor 项目 GitHub 地址：https://github.com/Meituan-Dianping/SQLAdvisor 压缩MyISAM：以上说到的两种类型的表都可以用myisamchk工具压缩。这种类型的表进一步减小了占用的存储，但是这种表压缩之后不能再被修改。另外，因为是压缩数据，所以这种表在读取的时候要先时行解压缩。 &emsp;&emsp;当然不管是何种MyISAM表，目前它都不支持事务，行级锁和外键约束的功能，这就意味着有事务处理需求的表，不能使用MyISAM存储引擎。MyISAM存储引擎特别适合在以下几种情况下使用： 选择密集型的表。MyISAM存储引擎在筛选大量数据时非常迅速，这是它最突出的优点。 插入密集型的表。MyISAM的并发插入特性允许同时选择和插入数据。 &emsp;&emsp;MyISAM表是独立于操作系统的，这说明可以轻松地将其从Windows服务器移植到Linux服务器；每当我们建立一个MyISAM引擎的表时，就会在本地磁盘上建立三个文件，文件名就是表名。 例如我创建了一个【test】表，那么就会生成以下三个文件： 文件名 说明 test.frm 存储表定义 test.MYD 存储数据 test.MYI 存储索引 InnoDB 引擎 &emsp;&emsp;InnoDB表类型可以看作是对MyISAM的进一步更新产品，它提供了事务、行级锁机制和外键约束的功能。InnoDB的表需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。 &emsp;&emsp;使用InnoDB是最理想的选择： 更新密集的表：InnoDB存储引擎特别适合处理多重并发的更新请求。 事务：InnoDB存储引擎是支持事务的标准MySQL存储引擎。 自动灾难恢复：与其它存储引擎不同，InnoDB表能够自动从灾难中恢复。 外键约束：MySQL支持外键的存储引擎只有InnoDB。 支持自动增加列AUTO_INCREMENT属性。 存储引擎操作 查看存储引擎想要查看我们的数据表使用了什么存储引擎，我们就需要使用到我们以前已经介绍过的【show】命令，语法如下： SHOW CREATE TABLE 表名; 存储引擎变更变更我们存储表的存储引擎将使用到的是我们前面使用过的【ALTER】命令，语法如下： ALTER TABLE 表名 ENGINE=新引擎; 修改默认引擎要使用事务功能，就必须将表设置为InnoDB引擎，有的版本在安装时，是未激活InnoDB引擎的，所以需要我们手动进行激活。首先我们进入MySQL的安装目录，找到my.ini文件。修改【default-storage-engine】这一行，将其修改为【default-storage-engine=InnoDB】即可，我们就成功的将默认的引擎修改为【InnoDB】","categories":[{"name":"数据库","slug":"数据库","permalink":"https://ewedwc.github.io/categories/数据库/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://ewedwc.github.io/tags/MySQL/"},{"name":"关系型数据库","slug":"关系型数据库","permalink":"https://ewedwc.github.io/tags/关系型数据库/"}],"keywords":[{"name":"数据库","slug":"数据库","permalink":"https://ewedwc.github.io/categories/数据库/"}]},{"title":"Linux中find命令用法全汇总","slug":"Linux中find命令用法全汇总","date":"2018-09-15T07:50:24.000Z","updated":"2018-11-15T13:22:52.465Z","comments":true,"path":"categories/da44e512.html","link":"","permalink":"https://ewedwc.github.io/categories/da44e512.html","excerpt":"","text":"第一部分:查找名称查找文件的基本查找命令 1.使用当前目录中的名称查找文件在当前工作目录中查找名称为test.c的所有文件。 12&gt;&gt;&gt;find test.ctest.c 2.在主目录下查找文件查找/home目录下的所有文件，名称为test。 123&gt;&gt;&gt;find /home -name test#无权限目录不进行查找/home/neil/Code/test 3.使用名称或忽略案例查找文件找到名称为test的所有文件，并在/home目录中同时包含大写和小写字母。 1234&gt;&gt;&gt;find /home -iname test#-i 忽略大小写/home/neil/Code/test/home/neil/Code/Test 4.使用名称按类型查找在/目录中查找名称为test的所有目录。 1&gt;&gt;&gt;find / -type d -name test 在当前文件中查找名称为test.php的文件 1&gt;&gt;&gt;find -type f -name test.php 第二部分:根据他们的权限查找文件 5.查找777的权限的文件查找权限为777 的所有文件 12&gt;&gt;&gt;find -type f -perm 777 -print#-print 格式化输出在文件的名前面加./ 查找所有文件没有777权限的文件 1&gt;&gt;&gt;find / -type f ! -perm 777 6.查找具有644的权限的SGID文件查找权限设置为644的所有SGID位的文件 1&gt;&gt;&gt;find / -perm 2644 7.查找具有551权限的粘滞位文件。查找权限为511的所有sticky Bit设置文件。 1&gt;&gt;&gt;find / -perm 1551 8.查找SUID文件查找所有SUID集文件。 1&gt;&gt;&gt;finde / -perm /u=s 9.查找只读文件查找所有只读文件。 1&gt;&gt;&gt;find / -perm /u=r 10.查找可执行文件查找所有可执行文件 1&gt;&gt;&gt;find / -perm /a=x 11.找到777的权限和chmod到644的文件查找所有777的权限文件，并使用chmod命令将权限设置为644 1234&gt;&gt;&gt;find / -type f -perm 0777 -print -exec chmod 644 &#123;&#125; \\;#-exec 将前面产生的结果当成参数一个一个的传给后面的命令执行#-args 将前面产生的结果当成参数一次性穿个后面的命令执行，不过可以用 -n指定个数#|前面命令的标准输出，当成后面命令的标准输入 12.找到具有777的权限的目录和chmod到755查找所有777的权限的目录，并使chmod 命令将权限设置为755 1&gt;&gt;&gt;find / -type d -perm 777 -print -exec chmod 755 &#123;&#125; \\; 13.查找并删除多个文件查找和删除多个文件，如.mp3或.txt,然后使用。 12&gt;&gt;&gt;find -type f -name &quot;*.txt&quot; -exec rm -f &#123;&#125; \\;&gt;&gt;&gt;find -type f -name &quot;*.mp3&quot; -exec rm -f &#123;&#125; \\; 14.查找所有空文件和目录在特定路径下查找所用空文件 1&gt;&gt;&gt;find /tmp -type f -empty 在特定路径下的空目录归档 1&gt;&gt;&gt;find /tmp -type d -empty 15.查找所有隐藏文件查找所有隐藏的文件，请使用以下命令。 1&gt;&gt;&gt;find /tmp -type f -name &quot;.*&quot; 第三部分:基于所有者和组的搜索文件 16.查找基于用户的单个文件在所有者root的/root 目录下查找名为test.c的所有或单个文件。 1&gt;&gt;&gt;find / -user root -name test.c 17.查找基于用户和组的所有文件。查找～目录下属于用户neil的所有文件 1&gt;&gt;&gt;find ~ -user neil 查找/home目录下属于Group Developer的所有文件。 1&gt;&gt;&gt;find /home -group Developer 18.查找用户的特定文件查找～目录下用户neil的所有.txt文件 1&gt;&gt;&gt;find ~ -user neil -iname &quot;*.c&quot; 第四部分: 根据日期和时间查找文件和目录 19.查找50天后访问的所有文件。查找50天后访问的所有文件。 1&gt;&gt;&gt;find / -atime 50 20.查找最后50-100天修改的文件查找所有被修改超过50天以及少于100天的文件。 1&gt;&gt;&gt;find / -mtime +50 -mtime -100 21.在过去1小时内更改的所有文件 1&gt;&gt;&gt;find /cmin -60 22.查找在最近一小时内更改的所有文件 1&gt;&gt;&gt;find / -mtime -60 22.查找最近1小时内访问的文件 1&gt;&gt;&gt;find / -amin -60 第五部分: 根据大小查找文件和目录 23.找的50MB的文件 1&gt;&gt;&gt;find /-size 50M 24.查找大小在50M到100M之间的所有文件 1&gt;&gt;&gt;find / -size +50M -size -100M 25.查找并删除100MB的文件 1&gt;&gt;&gt;find / -size 100M -exec rm -rf &#123;&#125; \\; 26.查找特定文件并删除 1&gt;&gt;&gt;find / -type f -name *.mp3 -size +10M -exec rm &#123;&#125; \\;","categories":[{"name":"Linux基础","slug":"Linux基础","permalink":"https://ewedwc.github.io/categories/Linux基础/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://ewedwc.github.io/tags/Linux/"}],"keywords":[{"name":"Linux基础","slug":"Linux基础","permalink":"https://ewedwc.github.io/categories/Linux基础/"}]},{"title":"HTTPS协议详解一","slug":"HTTPS协议详解","date":"2018-08-16T14:08:08.000Z","updated":"2018-11-16T15:10:37.596Z","comments":true,"path":"categories/2c037513.html","link":"","permalink":"https://ewedwc.github.io/categories/2c037513.html","excerpt":"","text":"HTTPS协议概述 HTTPS可以认为是HTTP+TLS。 HTTP协议大家耳熟能详了，目前大部分WEB应用和网站都是使用HTTP协议传输的。TLS是传输层加密协议，它的前身是SSL协议，最早由Netscape公司于1995年发布，1999年经过IETF讨论和规范后，改名为TLS。如果没有特别说明，SSL和TLS说的都是同一个协议。HTTP和TLS在协议层的位置以及TLS协议的组成如下图： TLS协议主要有五部分：应用数据层协议，握手协议，报警协议，加密消息确认协议，心跳协议TLS协议本身又是由Record协议传输的，Record协议的格式如上图最右所示。目前常用的HTTP协议是HTTP1.1，常用的TLS协议版本有如下几个：TLS1.3，TLS1.2,TLS1.1,TLS1.0和SSL3.0。其中SSL3.0由于POODLE攻击已经被证明不安全，但统计发现依然有不到1%的浏览器使用SSL3.0。TLS1.0也存在部分安全漏洞，比如RC4和BEAST攻击。过去由于主流Web浏览器和应用程序中的TLS实现都支持降级协商过程，导致即使服务器支持最新版本，攻击者也有机会利用较弱的协议实施攻击。因此到2020年，所有主流Web浏览器都将取消TLS1.0和TLS1.1的支持。TLS1.2暂时没有已知的安全漏洞，比较安全，同时有大量扩展提升速度和性能，当前被较为普遍的使用。需要关注一点的就是TLS1.3是TLS协议一个非常重大的改革。不管是安全性还是用户访问速度都会有质的提升。TLS1.3协议的最终版本（RFC8446）已于2018年8月10日发布，各主流浏览器也逐渐支持TLS1.3。同时HTTP2也于2015年5月正式定稿（RFC7540），这个由SPDY协议演化而来的协议相比HTTP1.1又是一个非常重大的变动，能够明显提升应用层数据的传输效率。 HTTPS功能介绍 1.内容加密。浏览器到服务器的内容都是以加密形式传输，中间者无法直接查看原始内容； 2.身份认证。保证用户访问的是百度服务，即使被DNS劫持到了第三方站点，也会提醒用户没有访问百度服务，有可能被劫持； 3.数据完整性。防止内容被第三方冒充或者篡改。HTTPS原理介绍 1.内容加密&emsp;&emsp;加密算法一般分为两种，对称加密和非对称加密。所谓对称加密（也叫密钥加密）就是指加密和解密使用的是相同的密钥。而非对称加密（也叫公钥加密）就是指加密和解密使用了不同的密钥。123mermaidgraph LR A[Baidu https] -. 加密 .-&gt; B((密文 saddas)) -. 解密 .-&gt; C[Baidu https] 123mermaidgraph LR A[Baidu https] -. 加密(密钥A) .-&gt; B((密文 saddas)) -. 解密（密钥B） .-&gt; C[Baidu https] 对称内容加密强度非常高，一般破解不了。但存在一个很大的问题就是无法安全地生成和保管密钥。假如客户端软件和服务器之间每次会话都使用固定的、相同的密钥加密和解密，肯定存在很大的安全隐患。如果有人从客户端获取到了对称密钥，整个内容就不存在安全性了，而且管理海量的客户端密钥也是一件很复杂的事情。 非对称加密主要用于密钥交换（也叫密钥协商），能够很好地解决这个问题。浏览器和服务器每次新建会话时都使用非对称密钥交换算法协商出对称密钥，使用这些对称密钥完成应用数据的加解密和验证，整个会话过程中的密钥只在内存中生成和保存，而且每个会话的对称密钥都不相同（除非会话复用），中间者无法窃取。 非对称密钥交换很安全，但同时也是HTTPS性能和速度严重降低的“罪魁祸首”。想要知道HTTPS为什么影响速度，为什么消耗资源，就一定要理解非对称密钥交换的整个过程。-下面重点介绍一下非对称密钥交换的数学原理及在TLS握手过程中的应用。 2.非对称密钥交换 在非对称密钥交换算法出现以前，对称加密一个很大的问题就是不知道如何安全生成和保管密钥。非对称密钥交换过程主要就是为了解决这个问题，使得对称密钥的生成和使用更加安全。 密钥交换算法本身非常复杂，密钥交换过程涉及到随机数生成，模指数运算，空白补齐，加密，签名等操作。 常见的密钥交换算法有RSA，ECDHE，DH，DHE等算法。它们的特性如下： RSA：算法实现简单，诞生于1977年，历史悠久，经过了长时间的破解测试，安全性高。缺点就是需要比较大的素数（目前常用的是2048位）来保证安全强度，很消耗CPU运算资源。RSA是目前唯一一个既能用于密钥交换又能用于证书签名的算法。 DH：Diffie-Hellman密钥交换算法，诞生时间比较早（1977年），但是1999年才公开。缺点是比较消耗CPU性能。 ECDHE：使用椭圆曲线（ECC）的DH算法，优点是能用较小的素数（256位）实现RSA相同的安全等级。缺点是算法实现复杂，用于密钥交换的历史不长，没有经过长时间的安全攻击测试。 ECDH：不支持PFS，安全性低，同时无法实现False Start。 DHE：不支持ECC。非常消耗CPU资源。 建议优先支持RSA和ECDH_RSA密钥交换算法。原因是： ECDHE支持ECC加速，计算速度更快。支持PFS，更加安全。支持False Start，用户访问速度更快。 目前还有至少20%以上的客户端不支持ECDHE，我们推荐使用RSA而不是DH或者DHE，因为DH系列算法非常消耗CPU（相当于要做两次RSA计算）。 非对称加密相比对称加密更加安全，但也存在两个明显缺点： CPU计算资源消耗非常大。一次完全TLS握手，密钥交换时的非对称解密计算量占整个握手过程的90%以上。而对称加密的计算量只相当于非对称加密的0.1%，如果应用层数据也使用非对称加解密，性能开销太大，无法承受。 非对称加密算法对加密内容的长度有限制，不能超过公钥长度。比如现在常用的公钥长度是2048位，意味着待加密内容不能超过256个字节。 所以公钥加密目前只能用来作密钥交换或者内容签名，不适合用来做应用层传输内容的加解密。 非对称密钥交换算法是整个HTTPS得以安全的基石，充分理解非对称密钥交换算法是理解HTTPS协议和功能的关键。","categories":[{"name":"Linux基础","slug":"Linux基础","permalink":"https://ewedwc.github.io/categories/Linux基础/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://ewedwc.github.io/tags/Linux/"},{"name":"网络协议","slug":"网络协议","permalink":"https://ewedwc.github.io/tags/网络协议/"}],"keywords":[{"name":"Linux基础","slug":"Linux基础","permalink":"https://ewedwc.github.io/categories/Linux基础/"}]},{"title":"Python算法之线性表","slug":"Python算法之线性表","date":"2018-08-01T04:12:27.000Z","updated":"2018-11-17T05:39:19.611Z","comments":true,"path":"categories/a4ff7c5d.html","link":"","permalink":"https://ewedwc.github.io/categories/a4ff7c5d.html","excerpt":"","text":"线性表及分类&emsp;&emsp;线性表是一类元素序列的抽象，是某类元素的集合，记录者元素之间的顺序关系。python中的list和tuple对支持线性表的需要，只是tuple中元素固定，而list则灵活的多。 顺序表:将表中的元素顺序地存储在一大块连续的存储区内，这样实现的表称为顺序表。 链表:将元素存储在由链接构造起来的一系列存储块内，这样实现的表称为链表。 顺序表的优缺点优点:O(1)时间的按位置访问元素；元素在表里存储紧凑，除表元素存储区外只需要O（1）空间存放少量的辅助信息。缺点:需要连续存储，一旦确定存储块大小，表的存储容量就确定，更改麻烦，在执行加入和删除操作时，要移动许多元素。 Python中list的常用方法 1.创建列表 12list = [&quot;1&quot;,&quot;2&quot;,&quot;3&quot;]list = [] #创建空列表 2.添加新元素 123list.append(ob) #在list末尾增加一个元素list.insert(n,&quot;4&quot;) #在指定位置添加元素，如果下标不存在就在末尾添加list.extend(list2) #合并两个list list2中仍有元素 3.查看列表中的值 1234print(list) #遍历列表print(list[n]) #使用下标索引来访问列表中的值print(list.count(ob)) #查看某个元素在这个列表中的个数，如果该元素不存在，那么返回0print(list.index(ob)) #找到这个元素的小标，如果有多个，返回第一个，如果找一个不存在的元素会报错 4.删除list中的元素 1234567list.pop()删除最后一个元素list.pop(n)指定下标，删除指定的元素，如果删除一个不存在的元素会报错list.remove(ob)删除list里面的一个元素，有多个相同元素，删除第一个print(list.pop())有返回值print(list.remove())无返回值del list[n]删除指定下标对应的元素del list 删除整个列表，list删除后无法访问 5.列表的排序和反转 1234list.reverse()将列表反转list.sort()排序，默认升序list.sort（reverse=True）降序排列注:list中有字符串，数字是不能排序，排序针对同种类型 6.列表操作函数 123456len(list):列表元素个数max(list):列表元素最大值min(list):返回列表元素的最小值enumerate:打印元素对应的下标for i，v in enumerate(list): print(&quot;&#123;&#125;&#123;&#125;&quot;.format(i,v)) 7.list切片 12345678name[n:m] 切片是不包含后面的那个元素的值（顾头不顾尾）name[:m] 如果切片的第一个元素的值缺省的话，从头开始取name[n:] 如果切片后面的值缺省的话，取到末尾name[:] 全部取出name[n:m:s] s:步长 隔多少个元素去一个步长是正数，从左往右取步长是负数，从右往左取注：切片同样适用于字符串，字符串也有下标 8.列表生成式 1list = [m +n for m in &quot;dsaad&quot; for n in &quot;SADASD&quot;] 顺序表面试题 1.1删除排序数组中的重复数字给出数组 A =[1,1,2]，你的函数应该返回长度 2，此时 A=[1,2]。 12345678910 def removeDuplicates(nums): k = 0 for i in range(1, len(nums)): if nums[i] != nums[k]: k += 1 nums[k] = nums[i] del nums[k + 1:len(nums)] return nums,len(nums)nums = [1, 1, 2, 3, 4, 5, 5, 5, 6, 7, 8, 8, 9, 9]print(removeDuplicates(nums)) 1.2两数之和给一个整数数组，找到两个数使得他们的和等于一个给定的数 target。返回这两个数的下标, 并且第一个下标小于第二个下标。注:twoSum意这里下标的范围是 1 到n，不是以0开头。 给出 numbers =[2,7,11,15], target =9, 返回[1,2] 123456789def twosum(list, target): hash_map = &#123;&#125; for i, v in enumerate(list): hash_map[v] = i for index1, v in enumerate(list): if target - v in hash_map: index2 = hash_map[target - v] if (index1 != index2) and (index1&lt;index2): return [index1 + 1, index2 + 1] 1.3删除元素 给定一个数组和一个值，在原地删除与值相同的数字，返回新数组的长度。元素的顺序可以改变，并且对新的数组不会有影响。给出一个数组 [0,4,4,0,0,2,4,4]，和值 4 1234567891011121314151617181920def delitem(list, num): if None == list: return 0 start = 0 stop = len(list) - 1 while start &lt; stop: if list[start] == num: if list[stop] != num: list[start], list[stop] = list[stop], list[start] start += 1 stop -= 1 else: stop -= 1 else: start +=1 del list[stop+1:len(list)] return listlist = [1, 2, 3, 4, 5, 6, 7, 4, 4, 4]b = delitem(list, 4)print(b) 1.4给一个由包含一串数字的列表组成的非负整数加上一。例子:输入: [1, 2, 3, 4, 9] 输出: [1, 2, 3, 5, 0] 1234567891011121314def plusOne(digits): len_s = len(digits) carry = 1 for i in range(len_s-1,-1,-1): total = digits[i] + carry digit = int(total % 10) carry = int(total / 10) digits[i] =digit if 1 == carry: digits.insert(0,1) return digitslist = [1,2,3,4,5]a = plusOne(list)print(a) 1.5爬楼梯问题假设你正在爬楼梯，需要 n 步你才能到达顶部。但每次你只能爬一步或者两步，你能有多 少种不同的方法爬到楼顶部? 1234567891011class Solution: # @param n, an integer # @return an integer def climbStairs(self, n): if n &lt;= 1: return 1 arr = [1, 1, 0] # look here, arr[0] = 1, arr[1] = 2 for i in range(2, n + 1): arr[2] = arr[0] + arr[1] arr[0], arr[1] = arr[1], arr[2] return arr[2] 1.6 落单的数给出 2*n + 1 个的数字，除其中一个数字之外其他每个数字均出现两次，找到这个数字。 1234567891011121314class Solution: # @param A, a list of integer # @return an integer def singleNumber(self, A): len_A = len(A) if 0 == len_A: return 0 elif 1 == len_A: return A[0] else: result = A[0] for i in range(1, len_A): result ^= A[i] return result 1.7删除排序数组中的重复数字，其他条件不变，如果可以允许出现两次重复将如何处理?给出数组 nums = [1,1,1,2,2,3],你的函数应当返回长度length=5, 且前5个元素分别为1,1,2,2and3. 1234567891011121314151617class Solution(object): def removeDuplicates(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; count = 0 for i in range(len(nums)): if count &lt; 2 or nums[count - 2] != nums[i]: nums[count] = nums[i] count += 1 return countif __name__ == &quot;__main__&quot;: l = [1, 1, 1, 2, 2, 3] r = Solution().removeDuplicates(l) assert l == [1, 1, 2, 2, 3, 3] assert r == 5","categories":[{"name":"Python开发","slug":"Python开发","permalink":"https://ewedwc.github.io/categories/Python开发/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://ewedwc.github.io/tags/算法/"},{"name":"python","slug":"python","permalink":"https://ewedwc.github.io/tags/python/"}],"keywords":[{"name":"Python开发","slug":"Python开发","permalink":"https://ewedwc.github.io/categories/Python开发/"}]},{"title":"Leetcode4~5","slug":"Leetcode4-5","date":"2018-07-02T10:52:39.000Z","updated":"2018-12-02T13:06:51.564Z","comments":true,"path":"categories/592e4e2d.html","link":"","permalink":"https://ewedwc.github.io/categories/592e4e2d.html","excerpt":"","text":"4.寻找两个有序数组的中位数题目描述给定两个大小为m和n的有序数组 nums1 和 nums2。请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为O(log(m+n))。你可以假设 nums1 和nums2 不会同时为空。示例 11234nums1 = [1, 3]nums2 = [2]则中位数是 2.0 示例 21234nums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3)/2 = 2.5 代码123456789101112131415161718192021222324252627282930313233343536class Solution(object): def findMedianSortedArrays(self, nums1, nums2): &quot;&quot;&quot; :type nums1: List[int] :type nums2: List[int] :rtype: float &quot;&quot;&quot; length1 = len(nums1) length2 = len(nums2) k = (length1 + length2) // 2 if (length1 + length2) % 2 == 0: return (self.findK(nums1, nums2, k) + self.findK(nums1, nums2, k - 1)) / 2.0; # 2 is enough in python3 else: return self.findK(nums1, nums2, k) def findK(self, num1, num2, k): # Recursive ends here if not num1: return num2[k] if not num2: return num1[k] if k == 0: return min(num1[0], num2[0]) length1 = len(num1) length2 = len(num2) if num1[length1 // 2] &gt; num2[length2 // 2]: if k &gt; length1 // 2 + length2 // 2: return self.findK(num1, num2[length2 // 2 + 1:], k - length2 // 2 - 1) else: return self.findK(num1[:length1 // 2], num2, k) else: if k &gt; length1 // 2 + length2 // 2: return self.findK(num1[length1 // 2 + 1:], num2, k - length1 // 2 - 1) else: return self.findK(num1, num2[:length2 // 2], k) 5.最长回文子串给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。示例1:123输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。 示例2:12输入: &quot;cbbd&quot;输出: &quot;bb&quot; 代码12345678910111213141516171819202122232425262728293031323334353637383940class Solution: def longestPalindrome(self, s): &quot;&quot;&quot; :type s: str :rtype: str &quot;&quot;&quot; if not s: return &quot;&quot; n = len(s) if n ==1: return s l = 0 r = 0 m = 0 c = 0 b = True for i in range(0,n): for j in range(0,min(n-i,i+1)): if (s[i-j] != s[i+j]): b = False break else: c = 2 * j + 1 if (c &gt; m): l = i - j + 1 - b r = i + j + b m = c b = True for j in range(0,min(n - i - 1,i+1)): if (s[i - j] != s[i+j+1]): b = False break else: c = 2 * j + 2 if (c &gt;m): l = i - j + 1 - b r = i + j + 1 + b m = c b = True return s[l:r]","categories":[{"name":"算法与数学之美","slug":"算法与数学之美","permalink":"https://ewedwc.github.io/categories/算法与数学之美/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://ewedwc.github.io/tags/算法/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://ewedwc.github.io/tags/Leetcode/"}],"keywords":[{"name":"算法与数学之美","slug":"算法与数学之美","permalink":"https://ewedwc.github.io/categories/算法与数学之美/"}]},{"title":"Leetcode1～3","slug":"Leetcode1～3","date":"2018-07-01T08:37:05.000Z","updated":"2018-11-26T11:00:08.182Z","comments":true,"path":"categories/82bff8a2.html","link":"","permalink":"https://ewedwc.github.io/categories/82bff8a2.html","excerpt":"","text":"1.两数之和题目描述给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的 两个 整数。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。示例 给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 代码1.暴力法12345678910111213141516class Solution: def twoSum(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: List[int] &quot;&quot;&quot; for i in range(len(nums)-1): for j in range(i+1,len(nums)): if nums[j] == target - nums[i]: return [i,j]nums = [2, 7, 11, 15]target = 9app = Solution()print(app.twoSum(nums,target)) 2.字典查找123456789101112131415161718192021class Solution: def twoSum(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: List[int] &quot;&quot;&quot; if not nums: return None d = &#123;&#125; for i, item in enumerate(nums): tmp = target - item for key, value in d.items(): if value == tmp: return [key, i] d[i] = item return None 2.两数相加题目描述给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。示例 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 代码12345678910111213141516171819202122232425262728# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def addTwoNumbers(self, l1, l2): &quot;&quot;&quot; :type l1: ListNode :type l2: ListNode :rtype: ListNode &quot;&quot;&quot; re = ListNode(0) r = re carry = 0 while (l1 or l2): x = l1.val if l1 else 0 y = l2.val if l2 else 0 s = carry + x + y carry = s // 10 r.next = ListNode(s%10) r = r.next if (l1 !=None):l1 = l1.next if (l2 !=None):l2 = l2.next if (carry&gt;0): r.next = ListNode(1) return re.next 3.无重复字符的最长子串题目描述给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。示例 1 输入: “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。 示例 2 输入: “bbbbb”输出: 1解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。 示例3 输入: “pwwkew”输出: 3解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。 代码12345678910111213141516171819202122class Solution: def lengthOfLongestSubstring(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; number = 0 max_number = 0 test =&quot;&quot; for i in s: if i not in test: test += i number += 1 else: if number &gt;= max_number: max_number = number index = test.index(i) test = test[(index+1):]+i number = len(test) if number &gt;max_number: max_number =number return max_number","categories":[{"name":"算法与数学之美","slug":"算法与数学之美","permalink":"https://ewedwc.github.io/categories/算法与数学之美/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://ewedwc.github.io/tags/算法/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://ewedwc.github.io/tags/Leetcode/"}],"keywords":[{"name":"算法与数学之美","slug":"算法与数学之美","permalink":"https://ewedwc.github.io/categories/算法与数学之美/"}]}]}